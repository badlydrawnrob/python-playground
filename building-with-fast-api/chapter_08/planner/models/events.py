# ------------------------------------------------------------------------------
# Our EVENT model (API layer)
# ==============================================================================
# > Aim to keep your API and DATA layers as simple as possible.
# > Actively leave things out! @ https://tinyurl.com/tesla-5-steps
# 
# We're not using `SQLModel` anymore! We're using Pydantic's `BaseModel` for any
# incoming request or response. This keeps the API layer and the DATA layer separate.
# 
# 
# Coding style
# ------------
# > Your SQL field values must be declared in the same order.
#
# For now the Pydantic fields are not named alphabetically, but by position.
# This is the same order as the book, but in a live app, I'd much prefer to keep
# an alphatical order for easier scanning. Python types are no where near as
# strict as Elm Lang, but do the best you can!
#
# 
# Architecture
# ------------
# > It's always wise to look at APIs out in the wild for ideas.
#
# Some public APIs use a `List ID` (such as list of image `/image-url/{id}`s which
# can be used to ping another endpoint to retrieve the assets. As we don't have
# a public API, we could simply `join` on the `Event` table to get all images as
# full URLs.
#
#
# Piccolo
# -------
# > See `planner/tables.py` for the DATA layer model.
#
# By default Piccolo returns a flat dictionary of values.
# 
#
# Using Pydantic
# --------------
# > Pydantic fields can be declared in any order, but keep them consistent.
# > Nested models can be used, but must be declared _before_ they are referenced.
#
# 1. Use `Optional` when a data point is not required.
#     - ALWAYS supply the fallback value:
#     - `Optional[type] = None` (old way) or `| None = None`!
#     - @ https://sentry.io/answers/understand-optional-query-parameters-in-fastapi/
#     - @ https://fastapi.tiangolo.com/tutorial/body/
# 2. Fields like `ID` are automatically handled by the ORM
#     - For these fields I don't think it's essential to add `None` fallback.
#     - When we used SQLModel, we had to add `ID: Optional[int] = None` ...
#     - We can now ignore this as we handover to our DATA model layer (PeeWee)
#     - @ https://sqlmodel.tiangolo.com/tutorial/automatic-id-none-refresh/
# 3. Use `ApiModel.model_dump(exclude_none=True)` with `DataModel(**kwargs)` for
#    a functional style of dumping an `Event` dictionary into Piccolo's queries.
#     - `exclude_none=True` removes any `None` values from the dictionary.
# 4. Elm lang prefers flatter model (so try not to nest models)
#     - I've had errors before with nested Pydantic models
# 5. `Field(alias=...)` can be used for special naming needs
#     - I think Pydantic only allows `underscore_fields`.
# 6. Prefer `PUT` to `PATCH` and be explicit with your values
#     - If it's a `null` value, declare it.
#     - All fields are optional in a `PATCH`, which can be harder to reason about.
# 
#
# FastAPI response typing
# -----------------------
# > Expects a response type of `-> dict`
#
# FastAPI expects a dictionary as it's response, and although it's not essential
# to type it, it's a good practice to assure the correct type and fields.
#
#
# WISHLIST
# --------
# 1. You can choose either `response_model=` or `-> ResponseType`
#     - But rarely will you need both. The former takes presedence.
# 2. Make sure data entry and return values are typed and predictable.
#     - @ https://mypy.readthedocs.io/en/stable/typed_dict.html

from pydantic import BaseModel, EmailStr, Field
from typing import List


class Event(BaseModel):
    """ Event model for incoming requests.
    
    The `ID` field is automatically generated by Piccolo. You don't have to supply
    it within the request body.
    """
    creator: int | None = None # Same as Optional[int] = None
    title: str
    image: str
    description: str
    location: str
    tags: List[str] | None = None


# ------------------------------------------------------------------------------
# Response
# ==============================================================================
# > Some examples I've provided of potential response models. I prefer a flatter
# > dictionary as Elm Lang prefers this. By default Piccolo responses leave out
# > the `ID`; depending on your design choices, you may not need a response model!
# 
# You _could_ have a different `response_model=` to the `-> ResponseType` to
# hide certain fields you want to keep private. In practice though, it seems best
# to use one or the other (not both) to keep things simple.
#
# 1. Use a Piccolo query to get the data from the database.
# 2. Convert the Piccolo dictionary response into a Pydantic model.
# 3. I've given some examples below of different response models.
#     - But we're only using the `EventWithCreator` model in this app.
#
#
# Old problems:
# -------------
#! ⚠️ For some reason `response_model=` doesn't work with `EventWithCreator`.
#! ⚠️ It works if you use it as the _return type_ of the function. So, it might
#! ⚠️ be better to just be explicit and do this manually.


class EventWithCreator(BaseModel):
    """ A response model with event creator.
    
    We've removed sensitive fields like `ID` and `password`.
    """
    creator_username: str = Field(alias="username")
    creator_email: EmailStr = Field(alias="email")
    title: str
    image: str
    description: str
    location: str
    tags: List[str] | None = None


class EventWithTitleOnly(BaseModel):
    """ A minimal response model with just the title. """
    title: str


class Creator(BaseModel):
    """ If you'd prefer a nested model with event creator.
    
    We've removed sensitive fields like `ID` and `password`.
    """
    username: str
    email: str

class EventWithNestedCreator(BaseModel):
    """If you'd prefer a nested model with event creator.
    
    Piccolo doesn't return the `ID` field by default.
    """
    creator: Creator
    title: str
    image: str
    description: str
    location: str
    tags: List[str]

